'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ensureNode = exports.search = exports.filter = exports.traverse = exports.countVisibleNodes = exports.getVisibleNodesByIndex = exports.sortNodes = exports.createFileNode = exports.createDirectoryNode = undefined;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _pathUtils = require('./pathUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createDirectoryNode = exports.createDirectoryNode = function createDirectoryNode(filePath) {
  return {
    type: 'directory',
    name: _path2.default.basename(filePath),
    path: filePath,
    children: {}
  };
};

var createFileNode = exports.createFileNode = function createFileNode(filePath) {
  return {
    type: 'file',
    name: _path2.default.basename(filePath),
    path: filePath
  };
};

// Sort nodes by directory first, then name
var sortNodes = exports.sortNodes = function sortNodes(children) {
  var nodes = Object.keys(children).map(function (key) {
    return children[key];
  });

  return nodes.sort(function (a, b) {
    if (a.type !== b.type) {
      if (a.type === 'directory') {
        return -1;
      } else {
        return 1;
      }
    }

    return a.name.toLocaleLowerCase().localeCompare(b.name.toLocaleLowerCase());
  });
};

var getVisibleNodesByIndex = exports.getVisibleNodesByIndex = function getVisibleNodesByIndex(root, metadata) {
  var targetIndex = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
  var targetCount = arguments.length <= 3 || arguments[3] === undefined ? Infinity : arguments[3];

  var currentIndex = 0;
  var currentCount = 0;
  var nodes = [];

  var getNode = function getNode(node, depth) {
    if (currentCount >= targetCount) {
      return;
    }

    if (currentIndex >= targetIndex) {
      nodes.push({
        node: node,
        depth: depth
      });
      currentCount++;
    }

    currentIndex++;

    if (metadata[node.path] && metadata[node.path].expanded) {
      var children = sortNodes(node.children);
      for (var i = 0; i < children.length; i++) {
        getNode(children[i], depth + 1);
      }
    }
  };

  getNode(root, 0);

  return nodes;
};

var countVisibleNodes = exports.countVisibleNodes = function countVisibleNodes(node, metadata) {
  var count = 1;

  if (metadata[node.path] && metadata[node.path].expanded) {
    var children = node.children;
    for (var key in children) {
      count += countVisibleNodes(children[key], metadata);
    }
  }

  return count;
};

var traverse = exports.traverse = function traverse(node, f, filePath) {
  filePath = filePath || node.path;

  var result = f(node, filePath);

  // Exit early if false is returned
  if (result === false) return result;

  if (node.type === 'directory') {
    var children = node.children;


    for (var key in children) {
      var _result = traverse(children[key], f, _path2.default.join(filePath, key));

      if (_result === false) return _result;
    }
  }
};

var filter = exports.filter = function filter(node, f) {
  var limit = arguments.length <= 2 || arguments[2] === undefined ? Infinity : arguments[2];

  var items = [];

  traverse(node, function (node, filePath) {
    f(node) && items.push(node);

    if (items.length >= limit) return false;
  });

  return items;
};

var search = exports.search = function search(node, matcher, type, limit) {
  var f = function f(node) {
    if (type && node.type !== type) {
      return false;
    } else {
      return node.path.match(matcher);
    }
  };

  return filter(node, f, limit);
};

var ensureNode = exports.ensureNode = function ensureNode(dirPath, state) {
  var parts = (0, _pathUtils.split)(dirPath);

  var _ref = _path2.default.parse ? _path2.default.parse(dirPath) : { root: '/' };

  var root = _ref.root;


  state = state || createDirectoryNode(root);

  var lastPart = state;
  var currentPath = root;
  while (parts.length) {
    var part = parts[0];
    currentPath = _path2.default.join(currentPath, part);

    // Create node if it doesn't exist
    if (!lastPart.children[part]) {
      lastPart.children[part] = createDirectoryNode(currentPath);
    }

    lastPart = lastPart.children[part];
    parts.shift();
  }

  return state;
};