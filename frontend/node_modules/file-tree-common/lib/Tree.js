'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _path2 = require('path');

var _path3 = _interopRequireDefault(_path2);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _pathUtils = require('./utils/pathUtils');

var _treeUtils = require('./utils/treeUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tree = function (_EventEmitter) {
  _inherits(Tree, _EventEmitter);

  function Tree() {
    var rootPath = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];

    _classCallCheck(this, Tree);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Tree).call(this));

    _this.emitChange = _this.emitChange.bind(_this);
    _this.startTransaction = _this.startTransaction.bind(_this);
    _this.finishTransaction = _this.finishTransaction.bind(_this);

    _this.inTransaction = false;
    _this._state = {
      version: 0
    };

    _this.set(rootPath);
    return _this;
  }

  _createClass(Tree, [{
    key: 'set',
    value: function set(rootPath, tree, stat, metadata) {
      this.rootPath = rootPath;

      var _state = this._state;


      this.startTransaction();

      if (tree || !_state.tree) {
        _state.tree = tree || (0, _treeUtils.ensureNode)(rootPath);
      } else {
        (0, _treeUtils.ensureNode)(rootPath, _state.tree);
      }

      if (stat || !_state.stat) {
        _state.stat = stat || {};
      }

      if (!_state.metadata) {
        _state.metadata = metadata || {};
      } else {
        for (var _path in metadata) {
          this.mergeMetadata(_path, metadata[_path]);
        }
      }

      this.finishTransaction();
    }
  }, {
    key: 'emitChange',
    value: function emitChange() {
      if (this.inTransaction) {
        return;
      }

      var _state = this._state;


      _state.version++;

      this.emit('change', this.state);
      this.emit('version', _state.version);
    }
  }, {
    key: 'startTransaction',
    value: function startTransaction() {
      if (this.inTransaction) {
        throw new Error('Already in transaction, can\'t start another.');
      }

      this.inTransaction = true;
    }
  }, {
    key: 'finishTransaction',
    value: function finishTransaction() {
      if (!this.inTransaction) {
        throw new Error('Can\'t end transaction, not in one.');
      }

      this.inTransaction = false;
      this.emitChange();
    }
  }, {
    key: 'get',
    value: function get(filePath) {
      var tree = this._state.tree;
      var rootPath = this.rootPath;


      var isWithin = (0, _pathUtils.within)(filePath, rootPath);

      if (!isWithin) {
        console.log('file-tree-common/tree: Can\'t get path ' + filePath + ' outside root ' + rootPath);
        return null;
      }

      var parts = (0, _pathUtils.split)(filePath);

      var parent = tree;
      while (parts.length) {
        var part = parts[0];

        if (typeof parent.children[part] === 'undefined') {
          return null;
        }

        parts.shift();
        parent = parent.children[part];
      }

      return parent;
    }
  }, {
    key: 'add',
    value: function add(itemPath, item) {
      var parentPath = _path3.default.dirname(itemPath);

      var parent = this.get(parentPath);
      if (!parent) {
        console.log('Can\'t add path - parent doesn\'t exist');
        return null;
      }

      var basePath = _path3.default.basename(itemPath);
      item.name = basePath;
      item.path = itemPath;
      parent.children[basePath] = item;

      this.emitChange();

      return item;
    }
  }, {
    key: 'addFile',
    value: function addFile(filePath, stat, metadata) {
      var item = this.add(filePath, (0, _treeUtils.createFileNode)(filePath));

      if (item) {
        if (stat) {
          this._state.stat[filePath] = stat;
        }
        metadata && this.mergeMetadata(filePath, metadata);
      }

      return item;
    }
  }, {
    key: 'addDir',
    value: function addDir(dirPath, stat, metadata) {
      var rootPath = this.rootPath;


      if (!(0, _pathUtils.within)(dirPath, rootPath) || dirPath === rootPath) {
        console.log('No need to add', dirPath);
        return null;
      }

      var item = this.add(dirPath, (0, _treeUtils.createDirectoryNode)(dirPath));

      if (item) {
        if (stat) {
          this._state.stat[dirPath] = stat;
        }
        metadata && this.mergeMetadata(dirPath, metadata);
      }

      return item;
    }
  }, {
    key: 'remove',
    value: function remove(itemPath) {
      var parentPath = _path3.default.dirname(itemPath);

      var parent = this.get(parentPath);
      if (!parent) {
        console.log('Can\'t add path - parent doesn\'t exist');
        return null;
      }

      var basePath = _path3.default.basename(itemPath);
      var item = parent.children[basePath];
      delete parent.children[basePath];
      this.deleteMetadata(itemPath);

      this.emitChange();

      return item;
    }
  }, {
    key: 'removeFile',
    value: function removeFile(itemPath) {
      this.remove(itemPath);
    }
  }, {
    key: 'removeDir',
    value: function removeDir(itemPath) {
      this.remove(itemPath);
    }
  }, {
    key: 'move',
    value: function move(oldPath, newPath) {
      var _this2 = this;

      var metadata = this._state.metadata;

      var itemMetadata = metadata[oldPath];
      var item = this.remove(oldPath);

      if (item) {
        this.add(newPath, item);
        metadata[newPath] = itemMetadata;

        // Update names and paths of children
        (0, _treeUtils.traverse)(item, function (child, childPath) {
          var basePath = _path3.default.basename(childPath);
          var oldChildPath = child.path;
          child.name = basePath;
          child.path = childPath;

          // a bit of duplication
          // we want the directories metadata to be present on the first noticeable "change" event
          if (childPath != newPath) {
            _this2.moveMetadata(oldChildPath, childPath);
          }
        });
      }

      this.emitChange();
    }
  }, {
    key: 'deleteMetadata',
    value: function deleteMetadata(itemPath) {
      delete this._state.metadata[itemPath];
    }
  }, {
    key: 'moveMetadata',
    value: function moveMetadata(oldPath, newPath) {
      var metadataCopy = _extends({}, this._state.metadata[oldPath]);
      delete this._state.metadata[oldPath];
      this._state.metadata[newPath] = metadataCopy;
    }
  }, {
    key: 'mergeMetadata',
    value: function mergeMetadata(itemPath, obj) {
      var metadata = this._state.metadata;


      var itemMetadata = metadata[itemPath];

      if (!itemMetadata) {
        metadata[itemPath] = obj;
      } else {
        Object.assign(itemMetadata, obj);
      }
    }
  }, {
    key: 'setMetadataField',
    value: function setMetadataField(itemPath, field, value) {
      var metadata = this._state.metadata[itemPath];

      if (!metadata) {
        metadata = this._state.metadata[itemPath] = {};
      }

      metadata[field] = value;

      this.emitChange();
    }
  }, {
    key: 'toJS',
    value: function toJS() {
      return this._state;
    }
  }, {
    key: 'state',
    get: function get() {
      var _state2 = this._state;
      var stat = _state2.stat;
      var metadata = _state2.metadata;
      var version = _state2.version;


      return {
        stat: stat,
        metadata: metadata,
        version: version,
        tree: this.get(this.rootPath)
      };
    }
  }]);

  return Tree;
}(_events2.default);

exports.default = Tree;